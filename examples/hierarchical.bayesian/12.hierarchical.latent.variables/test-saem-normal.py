
import sys
sys.path.append('./_model/normal')
sys.path.append('./_model')
from model import *
from utils import generate_variable

import numpy as np
import korali

def test_function(distrib, sample):
    all_latent_vars = sample["Latent Variables"]
    mean = sample["Mean"]
    cov = sample["Covariance Matrix"]
    all_llhs = sample["Log Likelihood"]

    import scipy.stats

    data = np.array(distrib._p.data)  # 200 x 1 x 3 -- last dim: id | x==0 | y
    import pdb
    pdb.set_trace()
    for indiv in range(len(data)):
      llh_korali = all_llhs[indiv]
      latents = all_latent_vars[indiv]
      llh = 0
      for point in data[indiv]:
          #print(f"LLH: {llh}")
          fx = normalModel(point[1], latents[0])
          llh_point = scipy.stats.norm.logpdf(point[2], fx, scale = latents[1])
          llh += llh_point
      assert np.isclose(llh_korali, llh)


def main():
    # Initialize the distribution
    distrib = NormalConditionalDistribution()

    # # rng = np.random.default_rng()
    # # initial_hyperparams = rng.standard_normal(2) # 1d mean and cov
    # initial_hyperparams = np.random.standard_normal(2) # 1d mean and cov

    k = korali.Engine()
    e = korali.Experiment()

    e["Problem"]["Type"] = "Bayesian/Latent/HierarchicalLatent"
    # The computational model for the log-likelihood, log[ p(data point | latent) ]
    e["Problem"]["Conditional Log Likelihood Function"] = lambda sample : distrib.conditional_p(sample)

    data_vector = [[] for _ in range(distrib._p.nIndividuals)]
    for i in range(distrib._p.nIndividuals):
        data_vector[i] = distrib._p.data[i].tolist()
    e["Problem"]["Data"] = data_vector
    e["Problem"]["Data Dimensions"] = distrib._p.nDataDimensions
    e["Problem"]["Number Individuals"] = distrib._p.nIndividuals
    e["Problem"]["Latent Space Dimensions"] = distrib._p.nLatentSpaceDimensions

    e["Solver"]["Type"] = "Executor2"
    e["Solver"]["Executions Per Generation" ] = 1
    e["Solver"]["Function To Execute"] = "Evaluate logLikelihood"
    #  e["Solver"]["Function To Execute"] = "Evaluate logPrior"  ;
    parmap1 = {}
    parmap2 = {}
    parmap1["Mean"] = [0., 1.]
    # The latents are assumed to already be in z-form, that is, log(latent)
    parmap2["Latent Variables"] = [[0.0, 1.1], [0.0, 1.1], [0.0, 1.1], [0.0, 1.1], [0.0, 1.1]]
    parmap2["Covariance Matrix"] = [[1.0, 0.0], [0., 1.]]
    e["Solver"][ "Vector Parameters" ] =  parmap1
    e["Solver"][ "Vector Of Vectors Parameters" ] =  parmap2
    e["Solver"][ "Vector Result Names"] = ["Log Likelihood"]
#  e["Solver"][ "Vector Result Names"] = std::vector(["Log Prior"]);
    e["Solver"]["Termination Criteria"]["Max Generations"] = 10
    e["Solver"]["Termination Criteria"]["Max Model Evaluations"] = 100
    e["Solver"]["Test Function"] = lambda sample: test_function(distrib, sample)

    e["Distributions"][0]["Name"] = "Uniform 0"
    e["Distributions"][0]["Type"] = "Univariate/Uniform"
    e["Distributions"][0]["Minimum"] = -100
    e["Distributions"][0]["Maximum"] = 100

    e["Distributions"][1]["Name"] = "Uniform 1"
    e["Distributions"][1]["Type"] = "Univariate/Uniform"
    e["Distributions"][1]["Minimum"] = 0
    e["Distributions"][1]["Maximum"] = 100

    e["Distributions"][2]["Name"] = "Uniform 2"
    e["Distributions"][2]["Type"] = "Univariate/Uniform"
    e["Distributions"][2]["Minimum"] = 0.0
    e["Distributions"][2]["Maximum"] = 1.0

    # * Define the variables:
    #   We only define one prototype latent variable vector for individual 0.
    #   The others will be automatically generated by Korali, as well as all hyperparameters.
    if np.isscalar(distrib._p.transf):
        distrib._p.transf = [distrib._p.transf]
    if np.isscalar(distrib._p.err_transf):
        distrib._p.err_transf = [distrib._p.err_transf]
    dimCounter = 0
    distribs = {"Normal": "Uniform 0", "Log-Normal": "Uniform 1",
                "Logit-Normal": "Uniform 2", "Probit-Normal": "Uniform XX"}
    for transf in distrib._p.transf:
        generate_variable(transf, e, dimCounter, "latent parameter "+str(dimCounter), distribs, initial=distrib._p.beta[dimCounter])
        dimCounter += 1

    for i, err_transf in enumerate(distrib._p.err_transf):
        generate_variable(err_transf,  e, dimCounter, "standard deviation "+str(i), distribs, initial=distrib._p.beta[dimCounter])
        dimCounter += 1

    assert dimCounter == distrib._p.dNormal + distrib._p.dLognormal + distrib._p.dLogitnormal + distrib._p.dProbitnormal

    e["File Output"]["Frequency"] = 1
    e["Console Output"]["Frequency"] = 1
    e["Console Output"]["Verbosity"] = "Normal"

    k.run(e)




if __name__ == '__main__':
    # # ** For debugging, try this: **
    # import sys, trace
    # sys.stdout = sys.stderr
    # tracer = trace.Trace(trace=1, count=0, ignoredirs=["/usr", sys.prefix])
    # tracer.runfunc(main)
    # # ** Else: **
    main()
