#ifndef _KORALI_SOLVER_LATENTVARIABLEFIM_HPP_
#define _KORALI_SOLVER_LATENTVARIABLEFIM_HPP_

#include "modules/distribution/multivariate/normal/normal.hpp"
#include "modules/distribution/univariate/normal/normal.hpp"
#include "modules/distribution/univariate/uniform/uniform.hpp"
#include "modules/problem/bayesian/latent/hierarchicalLowlevel/hierarchicalLowlevel.hpp"
#include "modules/solver/solver.hpp"

#include <gsl/gsl_blas.h> // Todo: Find out which of those are not needed; we only need the cholesky decomp
#include <gsl/gsl_linalg.h>
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_vector.h>

#include <random>

namespace korali
{
namespace solver
{
class LatentVariableFIM : public korali::Solver
{
  private:
  std::mt19937 rng; //* @brief Random number generator, used in shuffle

  public:
  /**
  * @brief The (lowlevel) latent variable problem that this hSAEM instance is solving. */
  korali::problem::bayesian::latent::HierarchicalLowlevel *_latentProblem;

  /**
  * @brief Draw samples of all latent variables, using a Metropolis-Hastings method.
  *        Uses the same proposal distributions as described in chapter 9.3 of
  *        "Mixed Effect Models for the Population Approach" by Marc Lavielle.
  *        If enabled, uses simulated annealing.
  */
  void sampleLatent();

  /** @brief  Calculates the Cholesky decomposition of the covariance. */
  void calculateCholesky();

  /** @brief Update the distribution used during sampling with the hyperparameter values.  */
  void updateMultivariateDistribution();

  /** @brief: Calculates four fractional exponents of the covariance, for use in calculating derivatives
            of the log-likelihood.
  @returns four vectors, each of size _latentSpaceDimensions:
    - the standard deviations (square of the covariance),
    - original covariance diagonal
    - 3rd power of standard deviations
    - 4th power of standard deviations
  Since we assume a diagonal covariance, this only returns the diagonal entries.
  */
  std::vector<std::vector<double>> covariancePowers();

  /** @brief Utility function to convert a vector of vectors into a concatenated 1D vector.
  *   @param v: The vector of vectors to flatten
  *   @returns a flattened vector
  */
  std::vector<double> flatten(const std::vector<std::vector<double>> &v);

  /**
  * @brief Utility function to calculate mean and standard deviation of the values in vector v.
  * @param v A 1D vector.
  * @return A two-element vector: {mean, stdev} (in this order)
  */
  //  std::vector<double> meanAndSDev(std::vector<double> v);

  /**
  *  @brief Utility function, "transposes" a vector of vectors of vectors @param data
            so that data[i][j][k] will be moved to result[j][k][i].
  * @param data A vector of vectors. All sub-vectors are expected to have same length. Represents a 3D-array.
  * @return result, a 3D array, so that data[i][j][k] is moved to result[j][i][k].
  */

  //  std::vector<std::vector<std::vector<double>>> transpose3D(const std::vector<std::vector<std::vector<double>>> data);

  /** @brief This is always run before (re-)starting the solver */
  void initialize() override;

  /** @brief Run once, before the first generation */
  void setInitialConfiguration() override;

  /** @brief Run a generation; main unit of execution. Only run once in this solver.*/
  void runGeneration() override;

  /** @brief Print information before each generation */
  //void printGenerationBefore() override;
  /** @brief Print information after each generation */
  //void printGenerationAfter() override;

  /** @brief Console output after sampling. Meant to check the sampling results;
        remove / do not call in final version, probably. */
  void printLastSamples();
  /** @brief Console output at termination. */
  void finalize() override;
};

} // namespace solver
} // namespace korali

#endif // _KORALI_SOLVER_LATENTVARIABLEFIM_HPP_
