#ifndef _KORALI_SOLVER_HSAEM_HPP_
#define _KORALI_SOLVER_HSAEM_HPP_

#include "modules/distribution/multivariate/normal/normal.hpp"
#include "modules/distribution/univariate/normal/normal.hpp"
#include "modules/distribution/univariate/uniform/uniform.hpp"
#include "modules/problem/bayesian/latent/hierarchicalLatent/hierarchicalLatent.hpp"
#include "modules/solver/solver.hpp"

#include <gsl/gsl_blas.h> // Todo: Find out which of those are not needed; we only need the cholesky decomp
#include <gsl/gsl_linalg.h>
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_vector.h>

namespace korali
{
namespace solver
{
class HSAEM : public korali::Solver
{
  public:
  /**
  * @brief Only needed at setup; could make this a local/temporary variable */
  korali::problem::bayesian::latent::HierarchicalLatent *_latentProblemWrapper;
  /**
  * @brief The (lowlevel) latent variable problem that this hSAEM instance is solving. */
  korali::problem::bayesian::latent::HierarchicalLatentLowlevel *_latentProblem;

  /**
  * @brief Draw samples of all latent variables, using a Metropolis-Hastings method.
  *        Uses the same proposal distributions as described in chapter 9.3 of
  *        "Mixed Effect Models for the Population Approach" by Marc Lavielle.
  *        If enabled, uses simulated annealing.
  */
  void sampleLatent();

  /** @brief After sampling, update the statistics (S1 and S2) used to update the hyperparameters.  */
  void updateS();

  /** @brief Update current estimates of the hyperparameters, using S1 and S2 statistics updated with new samples. */
  void updateHyperparameters();

  /** @brief A function to combine these sub-steps in the right order:
            - new covariance --> annealed covariance
              (also needed without SA because we use _annealedCovariance everywhere (it's just the same if no SA))
            - update chol of annealed covariance;
              update chol of original covariance
            - reset sampling distribution to new annealed covariance
    */
  void updateDistribution();

  /** @brief  Call after "annealCovariance()". Re-calculates the cholesky decomposition of the annealed covariance matrix.
              Also re-calculates a cholesky decomposition of the true current esimate of the covariance. */
  void updateCholesky();

  /** @brief  Call after updating hyperparameters: Updates the annealed covariance. If simulated annealing
              is enabled, it will be applied here: In earlier generations, the covariance is increased so that
              sampling happens across a wider range.

              Need to be already set up: _currentHyperparametersMean and _currentHyperparametersCovariance.
    */
  void annealCovariance();

  /** @brief Update the distribution used during sampling with new hyperparameter values.  */
  void updateAnnealedDistribution();

    /** @brief  Call after updating hyperparameters: Re-calculate the likelihood of all current samples.
                Need to be already set up: _currentHyperparametersMean and _currentHyperparametersCovariance and _currentZ
    */
  void updateProbabilities();

//  /**
//  * @brief initial things to run to test the hierarchical latent problem class. To be deleted.
//  */
//  void justTesting();

  /** @brief Utility function to convert a vector of vectors into a concatenated 1D vector.
  *   @param v: The vector of vectors to flatten
  *   @returns a flattened vector
  */
  std::vector<double> flatten(const std::vector<std::vector<double>> &v);
  /**
  * @brief Utility function to calculate mean and standard deviation of the values in vector v.
  * @param v A 1D vector.
  * @return A two-element vector: {mean, stdev} (in this order)
  */
  std::vector<double> meanAndSDev(std::vector<double> v);

  /**
  *  @brief Utility function, "transposes" a vector of vectors of vectors @param data,
            so that data[i][j][k] will be moved to result[j][k][i].
  * @param data A vector of vectors. All sub-vectors are expected to have same length. Represents a 3D-array.
  * @return result, a 3D array, so that data[i][j][k] is moved to result[j][i][k].
  */

  std::vector<std::vector<std::vector<double>>> transpose3D(const std::vector<std::vector<std::vector<double>>> data);



  // void finalize() override;

  /** @brief This is always run before (re-)starting the solver */
  void initialize() override;

  /** @brief Run once, before the first generation */
  void setInitialConfiguration() override;
  /** @brief Run a generation; main unit of execution. */
  void runGeneration() override;
  /** @brief Print information before each generation */
  void printGenerationBefore() override;
  /** @brief Print information after each generation */
  void printGenerationAfter() override;

  /**
 * @brief Final console output at termination.
 */
  void finalize() override;
};

} // namespace solver
} // namespace korali

#endif // _KORALI_SOLVER_HSAEM_HPP_
