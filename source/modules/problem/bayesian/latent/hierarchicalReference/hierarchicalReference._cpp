#include "modules/problem/bayesian/latent/hierarchicalReference/hierarchicalReference.hpp"
#include "sample/sample.hpp"

#include <map>
#include <math.h>

#include <gsl/gsl_blas.h>
#include <gsl/gsl_linalg.h>
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_vector.h>

#include <gsl/gsl_cdf.h>
#include <gsl/gsl_sf_gamma.h>

namespace korali
{
namespace problem
{
namespace bayesian
{
namespace latent
{
/* The problem initialization; here, create hyperparameter variables, add them to the problem's variable list,
    and set up index lists to find both types of variables in that list.*/
void HierarchicalReference::initialize()
{
  Latent::initialize();

  _numberIndividuals = _computationalModels.size();
  if (_numberIndividuals <= 0) KORALI_LOG_ERROR("Hierarchical latent variable problems require defining reference data.\n");

  _latentSpaceDimensions = _k->_variables.size();
  if (_k->_variables.size() < 1) KORALI_LOG_ERROR("Bayesian (%s) inference problems require at least one variable.\n", _likelihoodModel.c_str());

  if (_referenceData.size() == 0) KORALI_LOG_ERROR("Bayesian (%s) problems require defining reference data.\n", _likelihoodModel.c_str());

  //  // The user should define one variable per latent variable dimension, as prototype:
  //  if (_k->_variables.size() != _latentSpaceDimensions) KORALI_LOG_ERROR("Hierarchical latent variable problems require only a subset of prototype variables to be defined. Please define one prototype latent variable per individual. (Expected %d variables, found %d variables.) \n", _numberIndividuals, _k->_variables.size());

  /* Prepare the loglikelihood function.

   *** Implementation note: **
       This will result in the following call sequence:
        HSAEM ~~> this->evaluateLoglikelihood() ~~> lowlevelProblem->_evaluateLoglikelihood() ~~> this lambda function.
  */
  loglikelihoodLambdaFunction = [this](Sample &s) -> void {
    loglikelihoodFunction(s);
  };

  // * * Set up the low-level problem

  _koraliExperiment["Solver"]["Type"] = "HSAEM";
  // \__ do not change any other solver configuration -- this solver is supposedly never used.
  //     TODO: IF that ever changes, need to propagate _all_ solver configurations here!

  _koraliExperiment["Problem"]["Type"] = "Bayesian/Latent/HierarchicalLowlevel";
  _koraliExperiment["Problem"]["Log Likelihood Function"] = loglikelihoodLambdaFunction;
  _koraliExperiment["Problem"]["Latent Space Dimensions"] = _latentSpaceDimensions;
  _koraliExperiment["Problem"]["Number Individuals"] = _numberIndividuals;

  _koraliExperiment["Distributions"][0]["Name"] = "Dummy Prior";
  _koraliExperiment["Distributions"][0]["Type"] = "Univariate/Uniform";
  _koraliExperiment["Distributions"][0]["Minimum"] = -100;
  _koraliExperiment["Distributions"][0]["Maximum"] = 100;

  // * Create all variables: Additional latent variables as well as hyperparameters.
  // * 1. Determine how many latent variables are needed and create them.
  for (size_t i = 0; i < _numberIndividuals; i++)
  {
    for (size_t dim = 0; dim < _latentSpaceDimensions; dim++)
    {
      Variable *var = _k->_variables[dim];
      if (var->_bayesianType != "Latent") KORALI_LOG_ERROR("Expected prototype variables for latent variables only; found a hyperparameter. Hyperparameters will be created automatically.");
      //      if (var->_latentVariableDistributionType.c_str() == "NA") KORALI_LOG_ERROR("Latent variable distribution type 'NA' is only for internal use. Please choose a valid distribution.");
      _koraliExperiment["Variables"][i * _latentSpaceDimensions + dim]["Latent Variable Distribution Type"] = var->_latentVariableDistributionType;
      _koraliExperiment["Variables"][i * _latentSpaceDimensions + dim]["Bayesian Type"] = "Latent";
      _koraliExperiment["Variables"][i * _latentSpaceDimensions + dim]["Name"] = var->_name + " " + std::to_string(i);
      _koraliExperiment["Variables"][i * _latentSpaceDimensions + dim]["Individual Index"] = i;
      _koraliExperiment["Variables"][i * _latentSpaceDimensions + dim]["Latent Space Coordinate"] = dim;
      _koraliExperiment["Variables"][i * _latentSpaceDimensions + dim]["Initial Value"] = var->_initialValue;
      _koraliExperiment["Variables"][i * _latentSpaceDimensions + dim]["Prior Distribution"] = "Dummy Prior";
    }
  }

  /* Check and assign distribution types (of the latent variables), etc.*/
  for (size_t i = 0; i < _k->_variables.size(); i++)
  {
    // Check variables type
    std::string typeString = _k->_variables[i]->_bayesianType;
    if (typeString != "Latent") KORALI_LOG_ERROR("Unrecognized Variable Type %s \n", typeString.c_str());
  }

  /*  Now, generate the hyperparameters:
    1. Means - one mean per distinct 'Distribution Index'.
      Each mean is for whichever transformed version of the variable that is normally distributed. */
  int numberLatent = _latentSpaceDimensions * _numberIndividuals;
  for (size_t i = 0; i < _latentSpaceDimensions; i++)
  {
    Variable *var = _k->_variables[i];
    _koraliExperiment["Variables"][numberLatent + i]["Latent Variable Distribution Type"] = "NA";
    _koraliExperiment["Variables"][numberLatent + i]["Bayesian Type"] = "Hyperparameter";
    _koraliExperiment["Variables"][numberLatent + i]["Is Mean"] = true;
    _koraliExperiment["Variables"][numberLatent + i]["Name"] = "Mean of " + var->_name;
    _koraliExperiment["Variables"][numberLatent + i]["Individual Index"] = -1;
    _koraliExperiment["Variables"][numberLatent + i]["Latent Space Coordinate"] = i;
    _koraliExperiment["Variables"][numberLatent + i]["Prior Distribution"] = "Dummy Prior";
    //    _koraliExperiment["Variables"][numberLatent + i]["Initial Value"] = var->_initialValue;

    /* initialize variable's mean with the user-defined initial value (from one example latent variable representing this coordinate/ distribution index): */
    std::string distribString = var->_latentVariableDistributionType;
    double ival = var->_initialValue;
    if (distribString == "Normal")
    {
      _koraliExperiment["Variables"][numberLatent + i]["Initial Value"] = ival;
    }
    else
    {
      if (distribString == "Log-Normal")
      {
        if (ival <= 0)
          KORALI_LOG_ERROR("Initial value of log-normally distributed variable needs to be in range (0, infinity).");
        _koraliExperiment["Variables"][numberLatent + i]["Initial Value"] = log(ival);
      }
      else
      {
        if (distribString == "Logit-Normal")
        {
          if ((ival < 0) || (ival >= 1))
            KORALI_LOG_ERROR("Initial value of logit-normally distributed variable needs to be in range [0, 1).");
          _koraliExperiment["Variables"][numberLatent + i]["Initial Value"] = (ival / (1 - ival));
        }
        else
          KORALI_LOG_ERROR("Unrecognized 'Latent Variable Distribution' %s ", distribString.c_str());
      }
    }
  }

  /* 2. Create covariance matrices.
      Note: If ever required, could add 'groups' of variables that share a covariance matrix, while groups are independent of each other. */
  //  Degrees of freedom of the covariance matrix: n*(n+1)/2; we over-represent it as matrix
  for (size_t i = 0; i < _latentSpaceDimensions; i++)
  {
    for (size_t j = 0; j < _latentSpaceDimensions; j++)
    {
      Variable *vari = _k->_variables[i];
      Variable *varj = _k->_variables[j];
      int varIdx = numberLatent + _latentSpaceDimensions + i * _latentSpaceDimensions + j;
      _koraliExperiment["Variables"][varIdx]["Latent Variable Distribution Type"] = "NA";
      _koraliExperiment["Variables"][varIdx]["Bayesian Type"] = "Hyperparameter";
      _koraliExperiment["Variables"][varIdx]["Is Mean"] = false;
      _koraliExperiment["Variables"][varIdx]["Covariance I"] = i;
      _koraliExperiment["Variables"][varIdx]["Covariance J"] = j;
      _koraliExperiment["Variables"][varIdx]["Name"] = "Cov[" + std::to_string(i) + ", " + std::to_string(j) + "] between " + vari->_name + " and " + varj->_name;
      _koraliExperiment["Variables"][varIdx]["Individual Index"] = -1;
      _koraliExperiment["Variables"][varIdx]["Latent Space Coordinate"] = -1;
      _koraliExperiment["Variables"][varIdx]["Prior Distribution"] = "Dummy Prior";
      if (i == j)
        _koraliExperiment["Variables"][varIdx]["Initial Value"] = _initialVariance;
      else
        _koraliExperiment["Variables"][varIdx]["Initial Value"] = 0.0;
      //   _hyperparametersCovIndices[i].push_back(varIdx);
    }
  }

  _koraliExperiment["File Output"]["Frequency"] = 0;
  _koraliExperiment["File Output"]["Enabled"] = false;
  _koraliExperiment["Console Output"]["Frequency"] = 0;
  _koraliExperiment["Console Output"]["Verbosity"] = "Silent"; // Todo: Or propagate the current, user defined setting?
  _koraliExperiment["Random Seed"] = _k->_randomSeed++;

  /* Initialize the experiment and "extract" the lowlevel problem, so that we can call it's functions later. */
  _koraliEngine.initialize(_koraliExperiment);
  _lowlevelProblem = dynamic_cast<HierarchicalLowlevel *>(
    _koraliExperiment._problem);
}

HierarchicalReference::~HierarchicalReference()
{
  delete &_lowlevelProblem;
}

/**
  * @brief Evaluate all log-likelihoods for all individuals. Returns a list of log-likelihood values.
  * @param sample: Should contain field "Latent Variables" .

  Todo:
        - extract latent variables;
        - optionally, get the right data points for:
        - run each model
            - on possibly reverse-transformed latents
            for each: --> sample with sigma/di... and refrence values [y1, y2, ...]
            - re-copy the logLikelihoodNormal etc -->
            - feed the resulting sample into the right llh function
            - append the resulting llh to a list
        - return this list
 */

void HierarchicalReference::loglikelihoodFunction(Sample &sample)
{
  /* Set up a sample*/
  Sample llhSample;
  llhSample["Sample Id"] = KORALI_GET(int, sample, "Sample Id") + 1235;
  llhSample["Current Generation"] = _k->_currentGeneration;
  llhSample["Module"] = "Problem"; // not needed?

  std::vector<std::vector<double>> latentVariables = KORALI_GET(std::vector<std::vector<double>>, sample, "Latent Variables");
  std::vector<double> allLLHs(_numberIndividuals);

  for (size_t i = 0; i < _numberIndividuals; i++)
  {
    // Set to something invalid to prevent re-using former values
    llhSample["Reference Evaluations"] = 0;
    llhSample["Sigmas"] = 0;
    llhSample["Dispersions"] = 0;
    llhSample["Latent Variables"] = latentVariables[i];
    llhSample.run(_computationalModels[i]);

    if (_likelihoodModel == "Normal")
      loglikelihoodNormal(llhSample, _referenceData[i]);
    else if (_likelihoodModel == "Negative Binomial")
      loglikelihoodNegativeBinomial(llhSample, _referenceData[i]);
    else if (_likelihoodModel == "Positive Normal")
      loglikelihoodPositiveNormal(llhSample, _referenceData[i]);
    else
      KORALI_LOG_ERROR("Bayesian problem (%s) not recognized.\n", _likelihoodModel.c_str());

    allLLHs[i] = KORALI_GET(double, llhSample, "logLikelihood");
  }
  sample["logLikelihood"] = allLLHs;
}

double HierarchicalReference::compute_normalized_sse(std::vector<double> f, std::vector<double> g, std::vector<double> y)
{
  double sse = 0.;
  for (size_t i = 0; i < y.size(); i++)
  {
    double diff = (y[i] - f[i]) / g[i];
    sse += diff * diff;
  }
  return sse;
}

void HierarchicalReference::loglikelihoodNormal(Sample &sample, std::vector<double> referenceData)
{
  auto refEvals = KORALI_GET(std::vector<double>, sample, "Reference Evaluations");
  auto stdDevs = KORALI_GET(std::vector<double>, sample, "Standard Deviations");

  if (stdDevs.size() != referenceData.size())
    KORALI_LOG_ERROR("This Bayesian (%s) problem requires a %lu-sized Standard Deviation array. Provided: %lu.\n", _likelihoodModel.c_str(), referenceData.size(), stdDevs.size());

  if (refEvals.size() != referenceData.size())
    KORALI_LOG_ERROR("This Bayesian (%s) problem requires a %lu-sized Reference Evaluations array. Provided: %lu.\n", _likelihoodModel.c_str(), referenceData.size(), refEvals.size());

  double sse = -Inf;
  sse = compute_normalized_sse(refEvals, stdDevs, referenceData);

  double loglike = 0.;
  for (size_t i = 0; i < stdDevs.size(); i++)
  {
    if (stdDevs[i] <= 0.0) KORALI_LOG_ERROR("Negative or zero value (%lf) detected for the Standard Deviation.\n", stdDevs[i]);
    loglike -= log(stdDevs[i]);
  }

  loglike -= 0.5 * (referenceData.size() * _log2pi + sse);
  sample["logLikelihood"] = loglike;
}

void HierarchicalReference::loglikelihoodPositiveNormal(Sample &sample, std::vector<double> referenceData)
{
  auto refEvals = KORALI_GET(std::vector<double>, sample, "Reference Evaluations");
  auto stdDevs = KORALI_GET(std::vector<double>, sample, "Standard Deviations");

  if (stdDevs.size() != referenceData.size())
    KORALI_LOG_ERROR("This Bayesian (%s) problem requires a %lu-sized Standard Deviation array. Provided: %lu.\n", _likelihoodModel.c_str(), referenceData.size(), stdDevs.size());

  if (refEvals.size() != referenceData.size())
    KORALI_LOG_ERROR("This Bayesian (%s) problem requires a %lu-sized Reference Evaluations array. Provided: %lu.\n", _likelihoodModel.c_str(), referenceData.size(), refEvals.size());

  double loglike = 0.;
  for (size_t i = 0; i < stdDevs.size(); i++)
  {
    double m = refEvals[i];
    double s = stdDevs[i];

    if (s <= 0.0) KORALI_LOG_ERROR("Negative or zero value (%lf) detected for the Standard Deviation.\n", s);
    if (m < 0.0) KORALI_LOG_ERROR("Negative value (%lf) detected in Reference Evaluation.\n", m);
    if (referenceData[i] < 0.0) KORALI_LOG_ERROR("Negative value (%lf) detected in Reference Data.\n", referenceData[i]);

    double z = (referenceData[i] - m) / s;

    loglike -= 0.5 * (_log2pi + z * z);
    loglike -= log(s);
    loglike -= log(1. - gsl_cdf_gaussian_P(-m / s, 1.0));
  }

  sample["logLikelihood"] = loglike;
}

void HierarchicalReference::loglikelihoodNegativeBinomial(Sample &sample, std::vector<double> referenceData)
{
  auto refEvals = KORALI_GET(std::vector<double>, sample, "Reference Evaluations");
  auto dispersions = KORALI_GET(std::vector<double>, sample, "Dispersions");

  if (refEvals.size() != referenceData.size())
    KORALI_LOG_ERROR("This Bayesian (%s) problem requires a %lu-sized Reference Evaluations array. Provided: %lu.\n", _likelihoodModel.c_str(), referenceData.size(), refEvals.size());

  if (dispersions.size() != referenceData.size())
    KORALI_LOG_ERROR("This Bayesian (%s) problem requires a %lu-sized Dispersion array. Provided: %lu.\n", _likelihoodModel.c_str(), referenceData.size(), dispersions.size());

  size_t N = referenceData.size();
  double loglike = 0.0;

  for (size_t i = 0; i < N; i++)
  {
    double y = referenceData[i];
    loglike -= gsl_sf_lngamma(y + 1.);

    double m = refEvals[i];

    if (y < 0)
    {
      KORALI_LOG_ERROR("Negative Binomial Likelihood not defined for negative Reference Data (provided %lf.\n", y);
    }

    if (m <= 0)
    {
      sample["logLikelihood"] = -Inf;
      return;
    }

    double r = dispersions[i];

    double p = m / (m + r);

    loglike += gsl_sf_lngamma(y + r);
    loglike -= gsl_sf_lngamma(r);
    loglike += r * log(1 - p);
    loglike += y * log(p);
  }

  sample["logLikelihood"] = loglike;
}

/*** Implementation note: **
   We need to call the lowlevel problem's functions here, for all functions that can be called by name:
     sample[".. function to evaluate"] = "Evaluate Loglikelihood"
     conduit.start(sample)
   or similar. That is because the highlevel problem is still linked to _k and will be called at every
   such indirect call.
*/
void HierarchicalReference::evaluateLoglikelihood_(Sample &sample, bool zForm)
{
  _lowlevelProblem->evaluateLoglikelihood_(sample, zForm);
}
void HierarchicalReference::evaluateLoglikelihood(Sample &sample)
{
  _lowlevelProblem->evaluateLoglikelihood_(sample, true);
}

void HierarchicalReference::evaluateLogPosterior_(Sample &sample, bool zForm, bool cholesky)
{
  _lowlevelProblem->evaluateLogPosterior_(sample, zForm, cholesky);
}
void HierarchicalReference::evaluateLogPosterior(Sample &sample)
{
  _lowlevelProblem->evaluateLogPosterior_(sample, true, true);
}

void HierarchicalReference::evaluateLogPrior_(Sample &sample, bool zForm, bool cholesky)
{
  _lowlevelProblem->evaluateLogPrior_(sample, zForm, cholesky);
}
void HierarchicalReference::evaluateLogPrior(Sample &sample)
{
  _lowlevelProblem->evaluateLogPrior_(sample, true, true);
}

} // namespace latent
} // namespace bayesian
} // namespace problem
} // namespace korali