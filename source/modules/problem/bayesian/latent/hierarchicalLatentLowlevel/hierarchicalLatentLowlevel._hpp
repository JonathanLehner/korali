#ifndef _KORALI_PROBLEM_HIERARCHICALLATENTLOWLEVEL_HPP_
#define _KORALI_PROBLEM_HIERARCHICALLATENTLOWLEVEL_HPP_

#include "modules/distribution/multivariate/normal/normal.hpp"
#include "modules/problem/bayesian/bayesian.hpp"
#include "modules/problem/bayesian/latent/latent.hpp"

//#include <memory>

namespace korali
{
namespace problem
{
namespace bayesian
{
namespace latent
{
class HierarchicalLatentLowlevel : public korali::problem::bayesian::Latent
{
  private:
  // // local variables, but we don't want to re-allocate space at every use (or do we?)
  //  gsl_matrix* covMatrixGSL;
  //  gsl_matrix* chol;
  //  gsl_vector *latent_minus_mean;
  //  gsl_vector* x;

  //  void initializeGSLVariables(int nLatent);

  public:
  /**
  * @brief The problem initialization; here, create hyperparameter variables and set up index lists to
           find both types of variables
 */
  void initialize() override;

  /**
  * @brief De-allocate both vectors with hyperparameter korali-variables
 */
  // ~HierarchicalLatentLowlevel(void);

  /**
  * @brief Evaluate log of p(latent | hyperparameters), hyperparameter-dependent prior over each *transformed* latent variable.
    @param sample: Is expected to contain the fields ["Latent Variables"], ["Mean"] and ["Covariance Matrix"]. or
                    ["Covariance Cholesky Decomposition"]. Here, "Mean" should be a vector (size := n), "Covariance Matrix"
                     or "Covariance Cholesky Decomposition" should be an nxn vector of vectors. (No special encoding of the covariance.)
                    "Latent Variables" should be a vector of vectors, one * transformed * latent variable vector per individual. The order is
                    assumed to be the same as the order of variables according to their indices at problem definition
                    (["Variables"][THE_INDEX]["some property"] = ...).
    @param zForm:  A boolean indicating whether the latent variables are passed in z-Form (if zForm is true) or
                    whether "Latent Variables" are the untransformed values.
    @param cholesky: If true, the function expects a cholesky-decomposed covariance matrix in
                    sample["Covariance Cholesky Decomposition"]. If false, expects a non-decomposed covariance in
                    sample["Covariance Matrix"].
  * @returns sample["Log Prior"], a vector, with one log-prior for each latent variable.
 */
  void evaluateLogPrior_(korali::Sample &sample, bool zForm = true, bool cholesky = true);

  //  void evaluateLogPrior_old(korali::Sample &sample, bool zForm = true);

  /**
    @brief Same as evaluateLogPrior_(..., zForm = true, cholesky = true)
    @param sample: See other function description.
    */
  void evaluateLogPrior(korali::Sample &sample) override;

  /**
  * @brief Evaluate the total log-probability p(all data | all latent) * p(latent | hyperparameters).
            log[ p(all data | all latent) * p(all latent | hyperparameters) ]
            Note: Data is not handled by this problem class, it must be included in the definition of the
                  likelihood model functions.
    @param sample: Is expected to contain the fields ["Latent Variables"], ["Mean"] and ["Covariance Matrix"] or
                    ["Covariance Cholesky Decomposition"].
                    "Mean" should be a vector (size := n), "Covariance Matrix"/ "Covariance Cholesky Decomposition" should
                    be an nxn vector of vectors. (No special encoding of the cov, except as cholesky decomposition.)
    @param zForm:  A boolean indicating whether the latent variables are passed in z-Form (if zForm is true) or
                    whether "Latent Variables" are the untransformed values.
    @param cholesky: If true, the function expects a cholesky-decomposed covariance matrix in
                    sample["Covariance Cholesky Decomposition"]. If false, expects a non-decomposed covariance in
                    sample["Covariance Matrix"].
     @returns sample["Log Posterior"], a single value.
 */
  void evaluateLogPosterior_(korali::Sample &sample, bool zForm = true, bool cholesky = true);
  /**
    @brief Same as evaluateLogPosterior_(..., zForm = true)
    @param sample: See other function description
    */
  void evaluateLogPosterior(korali::Sample &sample) override;

  /**
    @brief Runs the function _logLikelihoodFunction, after optionally transforming the latent variables back from z space.
            Evaluate each log-likelihood log(p(data for individual i | latent variables i)),
            given the latent variables. Uses sample["Latent Variables"] which must be a vector of vectors of
            latent variables (one vector per individual).
            Note: "Latent Variables" can be overwritten in the process!
     @param sample: sample["Latent Variables"] should contain a list of lists / vector of vectors, one latent variable vector for each individual.
     @param zForm:  A boolean indicating whether the latent variables are passed in z-Form (if zForm is true) or
                    whether "Latent Variables" are the untransformed values.
     @returns : sample['Log Likelihood'], a list/vector with one log-likelihood per individual.
 */
  void evaluateLoglikelihood_(korali::Sample &sample, bool zForm = true);
  /**
    @brief Same as evaluateLoglikelihood_(..., zForm = true)
    @param sample: See other function description
    */
  void evaluateLoglikelihood(korali::Sample &sample) override;

  /**
  * @brief transform each coordinate of z back to the latent variable it corresponds to. (E.g. if a latent variable
  *        latent_i has a normal distribution, z_i == latent_i; if it is log-normal, exp(z_i) = latent_i, etc.
  * @param z: A vector with values for each z variable.
  * @returns A vector with "true", not-transformed latent variable values.
 */
  std::vector<double> zToLatent(std::vector<double> z);

  /**
  * @brief transform each coordinate of the latent variable vector into "z form": z = log(l) for l log-normal,
  *        z = logit(l) for l logit-normal.
  * @param v: A vector with latent variables.
  * @returns A vector with transfored, "z form" latent variables.
 */
  std::vector<double> latentToZ(std::vector<double> v);
};

} // namespace latent
} // namespace bayesian
} // namespace problem
} // namespace korali

#endif // _KORALI_PROBLEM_HIERARCHICALLATENTLOWLEVEL_HPP_
