#ifndef _KORALI_PROBLEM_HIERARCHICALLATENTLOWLEVEL_HPP_
#define _KORALI_PROBLEM_HIERARCHICALLATENTLOWLEVEL_HPP_

#include "modules/problem/bayesian/bayesian.hpp"
#include "modules/problem/bayesian/latent/latent.hpp"

//#include <memory>

namespace korali
{
namespace problem
{
namespace bayesian
{
namespace latent
{
class HierarchicalLatentLowlevel : public korali::problem::bayesian::Latent
{
  private:
  // // local variables, but we don't want to re-allocate space at every use (or do we?)
  //  gsl_matrix* covMatrixGSL;
  //  gsl_matrix* chol;
  //  gsl_vector *latent_minus_mean;
  //  gsl_vector* x;

  //  void initializeGSLVariables(int nLatent);

  public:
  /**
  * @brief The problem initialization; here, create hyperparameter variables and set up index lists to
           find both types of variables
 */
  void initialize() override;

  /**
  * @brief De-allocate both vectors with hyperparameter korali-variables
 */
  // ~HierarchicalLatentLowlevel(void);

  /**
  * @brief Evaluate log of p(latent | hyperparameters), hyperparameter-dependent prior over each *transformed* latent variable.
    @param sample: Is expected to contain the fields ["Latent Variables"], ["Mean"] and ["Covariance Matrix"]. Here, "Mean" should be
                    a vector (size := n), "Covariance Matrix" should be an nxn vector of vectors. (No special encoding of the covariance.)
                    "Latent Variables" should be a vector of vectors, one * transformed * latent variable vector per individual. The order is
                    assumed to be the same as the order of variables according to their indices at problem definition
                    (["Variables"][THE_INDEX]["some property"] = ...).
    @param zForm:  A boolean indicating whether the latent variables are passed in z-Form (if zForm is true) or
                    whether "Latent Variables" are the untransformed values.
  * @returns sample["Log Prior"], a vector, with one log-prior for each latent variable.
 */
  void evaluateLogPrior_(korali::Sample &sample, bool zForm = true);
  /**
    @brief Same as evaluateLogPrior_(..., zForm = true)
    @param sample: See other function description
    */
  void evaluateLogPrior(korali::Sample &sample) override;

  /**
  * @brief Evaluate the total log-probability p(all data | all latent) * p(latent | hyperparameters).
            log[ p(all data | all latent) * p(all latent | hyperparameters) ]
    @param sample: Is expected to contain the fields ["Latent Variables"], ["Mean"] and ["Covariance Matrix"].
                    Data was given at problem creation.
                    "Mean" should be a vector (size := n), "Covariance Matrix" should be an nxn vector of vectors.
                    (No special encoding of the cov.)
    @param zForm:  A boolean indicating whether the latent variables are passed in z-Form (if zForm is true) or
                    whether "Latent Variables" are the untransformed values.
     @returns sample["Log Posterior"], a single value.
 */
  void evaluateLogPosterior_(korali::Sample &sample, bool zForm = true ) ;
    /**
    @brief Same as evaluateLogPosterior_(..., zForm = true)
    @param sample: See other function description
    */
  void evaluateLogPosterior(korali::Sample &sample) override;

  /**
  * @brief Evaluate the user-defined function giving the conditional log-likelihood of one data point, given one
            vector of latent variables (for a single, unspecified individual).
            See the description of that function in the config for more information.
           (It will set "Conditional LogLikelihood" and use "Latent Variables" and "Data Point".)
  * @param sample: Should contain fields "Latent Variables" and "Data Point".
 */
  void evaluateLoglikelihoodSingle(korali::Sample &sample);

  /**
    @brief Evaluate each log-likelihood log(p(data for individual i | latent variables i)) across all data points
            assigned to the individual, given latent variables.
            Uses sample["Latent Variables"] which must be a vector of vectors of latent variables (one vector per individual).
            Note: "Latent Variables" will be overwritten in the process!
     @param sample: sample["Latent Variables"] should contain a list of lists / vector of vectors, one latent variable vector for each individual.
     @param zForm:  A boolean indicating whether the latent variables are passed in z-Form (if zForm is true) or
                    whether "Latent Variables" are the untransformed values.
     @returns : sample['Log Likelihood'], a list/vector with one log-likelihood per individual.
 */
  void evaluateLoglikelihood_(korali::Sample &sample, bool zForm = true);
 /**
    @brief Same as evaluateLoglikelihood_(..., zForm = true)
    @param sample: See other function description
    */
  void evaluateLoglikelihood(korali::Sample &sample) override;

  /**
  * @brief transform each coordinate of z back to the latent variable it corresponds to. (E.g. if a latent variable
  *        latent_i has a normal distribution, z_i == latent_i; if it is log-normal, exp(z_i) = latent_i, etc.
  * @param z: A vector with values for each z variable.
  * @returns A vector with "true", not-transformed latent variable values.
 */
  std::vector<double> zToLatent(std::vector<double> z);

  /**
  * @brief transform each coordinate of the latent variable vector into "z form": z = log(l) for l log-normal,
  *        z = logit(l) for l logit-normal.
  * @param v: A vector with latent variables.
  * @returns A vector with transfored, "z form" latent variables.
 */
  std::vector<double> latentToZ(std::vector<double> v);
};

} // namespace latent
} // namespace bayesian
} // namespace problem
} // namespace korali

#endif // _KORALI_PROBLEM_HIERARCHICALLATENTLOWLEVEL_HPP_
