#ifndef _KORALI_PROBLEM_HIERARCHICALLATENT_HPP_
#define _KORALI_PROBLEM_HIERARCHICALLATENT_HPP_

#include "engine.hpp"
#include "modules/experiment/experiment.hpp"
#include "modules/problem/bayesian/bayesian.hpp"
#include "modules/problem/bayesian/latent/hierarchicalLatentLowlevel/hierarchicalLatentLowlevel.hpp"
#include "modules/problem/bayesian/latent/latent.hpp"

//#include <memory>

namespace korali
{
namespace problem
{
namespace bayesian
{
namespace latent
{
class HierarchicalLatent : public korali::problem::bayesian::Latent
{
  private:
  public:
  /** @brief The lowlevel problem containing actual calculations. */
  korali::problem::bayesian::latent::HierarchicalLatentLowlevel *_lowlevelProblem;

  /**
  * @brief The problem initialization; here, create hyperparameter variables and set up index lists to
           find both types of variables
 */
  void initialize() override;

  /**
  * @brief Call destructor of sub-problem, just in case we want to do some de-allocation there
 */
  ~HierarchicalLatent();

  /**
    @brief Evaluate each log-likelihood log(p(data for individual i | latent variables i)) across all data points
            assigned to the individual, given latent variables.
            Uses sample["Latent Variables"] which must be a vector of vectors of latent variables (one vector per individual).
     @param sample: sample["Latent Variables"] should contain a list of lists / vector of vectors, one latent variable vector for each individual.
     @param zForm:  A boolean indicating whether the latent variables are passed in z-Form (if zForm is true) or
                    whether "Latent Variables" are the untransformed values.
     @returns : sample['Log Likelihood'], a list/vector with one log-likelihood per individual.
 */
  void evaluateLoglikelihood_(korali::Sample &sample, bool zForm = true);
   /**
    @brief Same as evaluateLogLikelihood_(..., zForm = true)
    @param sample: See other function description
    */
  void evaluateLoglikelihood(korali::Sample &sample) override;

  /**
  * @brief Evaluate the user-defined function giving the conditional log-likelihood of one data point, given one
            vector of latent variables (for a single, unspecified individual).
            See the description of that function in the config for more information.
           (It will set "Conditional LogLikelihood" and use "Latent Variables" and "Data Point".)
  * @param sample: Should contain fields "Latent Variables" and "Data Point".
 */
  void evaluateLoglikelihoodSingle(korali::Sample &sample);

  /**
  * @brief Evaluate log of p(latent | hyperparameters), hyperparameter-dependent prior over each *transformed* latent variable.
    @param sample: Is expected to contain the fields ["Latent Variables"], ["Mean"] and ["Covariance Matrix"]. or
                    ["Covariance Cholesky Decomposition"]. Here, "Mean" should be a vector (size := n), "Covariance Matrix"
                     or "Covariance Cholesky Decomposition" should be an nxn vector of vectors. (No special encoding of the covariance.)
                    "Latent Variables" should be a vector of vectors, one * transformed * latent variable vector per individual. The order is
                    assumed to be the same as the order of variables according to their indices at problem definition
                    (["Variables"][THE_INDEX]["some property"] = ...).
    @param zForm:  A boolean indicating whether the latent variables are passed in z-Form (if zForm is true) or
                    whether "Latent Variables" are the untransformed values.
    @param cholesky: If true, the function expects a cholesky-decomposed covariance matrix in
                    sample["Covariance Cholesky Decomposition"]. If false, expects a non-decomposed covariance in
                    sample["Covariance Matrix"].
  * @returns sample["Log Prior"], a vector, with one log-prior for each latent variable.
 */
  void evaluateLogPrior_(korali::Sample &sample, bool zForm = true, bool cholesky = true);
  /**
    @brief Same as evaluateLogPrior_(..., zForm = true, cholesky = true).
    @param sample: See other function description
    */
  void evaluateLogPrior(korali::Sample &sample) override;

  /**
  * @brief Evaluate the total log-probability p(all data | all latent) * p(latent | hyperparameters).
            log[ p(all data | all latent) * p(all latent | hyperparameters) ]
    @param sample: Is expected to contain the fields ["Latent Variables"], ["Mean"] and ["Covariance Matrix"] or
                    ["Covariance Cholesky Decomposition"].
                    Data was given at problem creation.
                    "Mean" should be a vector (size := n), "Covariance Matrix"/ "Covariance Cholesky Decomposition" should
                    be an nxn vector of vectors. (No special encoding of the cov, except as cholesky decomposition.)
    @param zForm:  A boolean indicating whether the latent variables are passed in z-Form (if zForm is true) or
                    whether "Latent Variables" are the untransformed values.
    @param cholesky: If true, the function expects a cholesky-decomposed covariance matrix in
                    sample["Covariance Cholesky Decomposition"]. If false, expects a non-decomposed covariance in
                    sample["Covariance Matrix"].
     @returns sample["Log Posterior"], a single value.
 */
  void evaluateLogPosterior_(korali::Sample &sample, bool zForm = true, bool cholesky = true);
  /**
    @brief Same as evaluateLogPosterior_(..., zForm = true, cholesky = true).
    @param sample: See other function description
    */
  void evaluateLogPosterior(korali::Sample &sample) override;

  /// @brief Korali experiment needed to create the sub-problem
  korali::Experiment _koraliExperiment;

  /**
 * @brief Korali engine needed to initialize the lowlevel problem / experiment.
 */
  korali::Engine _koraliEngine;
};

} // namespace latent
} // namespace bayesian
} // namespace problem
} // namespace korali

#endif // _KORALI_PROBLEM_HIERARCHICALLATENT_HPP_
