#ifndef _KORALI_PROBLEM_HIERARCHICALLATENT_HPP_
#define _KORALI_PROBLEM_HIERARCHICALLATENT_HPP_

#include "engine.hpp"
#include "modules/experiment/experiment.hpp"
#include "modules/problem/bayesian/bayesian.hpp"
#include "modules/problem/bayesian/latent/hierarchicalLowlevel/hierarchicalLowlevel.hpp"
#include "modules/problem/bayesian/latent/latent.hpp"

//#include <memory>

namespace korali
{
namespace problem
{
namespace bayesian
{
namespace latent
{
class HierarchicalCustom : public korali::problem::bayesian::Latent
{
  private:
  /**
    @brief Evaluate the conditional log-likelihood of all individuals. Exact same as evaluateLoglikelihood.
     @param sample: sample["Latent Variables"] should contain a list of lists / vector of vectors, one latent variable vector for each individual.
     @returns: sample["logLikelihood"], a list/vector with one log-likelihood per individual.
   */
  std::function<void(korali::Sample &s)> loglikelihoodLambdaFunction;

  public:
  /** @brief The lowlevel problem containing actual calculations. */
  HierarchicalLowlevel *_lowlevelProblem;

  /**
  * @brief The problem initialization; here, create hyperparameter variables and set up index lists to
           find both types of variables
 */
  void initialize() override;

  /**
  * @brief Call destructor of sub-problem, just in case we want to do some de-allocation there
 */
  ~HierarchicalCustom();

  /**
    @brief Evaluate each log-likelihood log(p(data for individual i | latent variables i)), given latent variables.
            Implementation note: Latent variables are expected in original (non-z) form, --because-- the
             HierarchicalLowlevel problem takes care of the transformation.
            If data points were given to the HierarchicalCustom problem, they will be passed to the custom
            likelihood functions and thus can be used there.
            Uses sample["Latent Variables"] which must be a vector of vectors of latent variables (one vector per individual).
     @param sample: sample["Latent Variables"] should contain a list of lists / vector of vectors, one latent variable vector for each individual.
     @returns : sample["logLikelihood"], a list/vector with one log-likelihood per individual.
 */
  void loglikelihoodFunction(korali::Sample &sample);

  /**
    @brief Calls the lowlevel problem's function of same name.
            Evaluate each log-likelihood log(p(data for individual i | latent variables i)) across all data points
            assigned to the individual, given latent variables.
            Uses sample["Latent Variables"] which must be a vector of vectors of latent variables (one vector per individual).
     @param sample: sample["Latent Variables"] should contain a list of lists / vector of vectors, one latent variable vector for each individual.
     @param zForm:  A boolean indicating whether the latent variables are passed in z-Form (if zForm is true) or
                    whether "Latent Variables" are the untransformed values.
     @returns : sample['Log Likelihood'], a list/vector with one log-likelihood per individual.
 */
  void evaluateLoglikelihood_(korali::Sample &sample, bool zForm = true);
  /**
    @brief Same as evaluateLogLikelihood_(..., zForm = true)
    @param sample: See other function description
    */
  void evaluateLoglikelihood(korali::Sample &sample) override;

  /**
  * @brief Evaluate log of p(latent | hyperparameters), hyperparameter-dependent prior over each *transformed* latent variable.
    @param sample: Is expected to contain the fields ["Latent Variables"], ["Mean"] and ["Covariance Matrix"]. or
                    ["Covariance Cholesky Decomposition"]. Here, "Mean" should be a vector (size := n), "Covariance Matrix"
                     or "Covariance Cholesky Decomposition" should be an nxn vector of vectors. (No special encoding of the covariance.)
                    "Latent Variables" should be a vector of vectors, one * transformed * latent variable vector per individual. The order is
                    assumed to be the same as the order of variables according to their indices at problem definition
                    (["Variables"][THE_INDEX]["some property"] = ...).
    @param zForm:  A boolean indicating whether the latent variables are passed in z-Form (if zForm is true) or
                    whether "Latent Variables" are the untransformed values.
    @param cholesky: If true, the function expects a cholesky-decomposed covariance matrix in
                    sample["Covariance Cholesky Decomposition"]. If false, expects a non-decomposed covariance in
                    sample["Covariance Matrix"].
  * @returns sample["Log Prior"], a vector, with one log-prior for each latent variable.
 */
  void evaluateLogPrior_(korali::Sample &sample, bool zForm = true, bool cholesky = true);
  /**
    @brief Same as evaluateLogPrior_(..., zForm = true, cholesky = true).
    @param sample: See other function description
    */
  void evaluateLogPrior(korali::Sample &sample) override;

  /**
  * @brief Evaluate the total log-probability p(all data | all latent) * p(latent | hyperparameters).
            log[ p(all data | all latent) * p(all latent | hyperparameters) ]
    @param sample: Is expected to contain the fields ["Latent Variables"], ["Mean"] and ["Covariance Matrix"] or
                    ["Covariance Cholesky Decomposition"].
                    Data was either included in the models by the user, or given at problem creation.
                    "Mean" should be a vector (size := n), "Covariance Matrix"/ "Covariance Cholesky Decomposition" should
                    be an nxn vector of vectors. (No special encoding of the cov, except as cholesky decomposition.)
    @param zForm:  A boolean indicating whether the latent variables are passed in z-Form (if zForm is true) or
                    whether "Latent Variables" are the untransformed values.
    @param cholesky: If true, the function expects a cholesky-decomposed covariance matrix in
                    sample["Covariance Cholesky Decomposition"]. If false, expects a non-decomposed covariance in
                    sample["Covariance Matrix"].
     @returns sample["Log Posterior"], a single value.
 */
  void evaluateLogPosterior_(korali::Sample &sample, bool zForm = true, bool cholesky = true);
  /**
    @brief Same as evaluateLogPosterior_(..., zForm = true, cholesky = true).
    @param sample: See other function description
    */
  void evaluateLogPosterior(korali::Sample &sample) override;

  /**
   * @brief Evaluates the gradient and Hessian of the log-probability, given the hyperparameters passed to the sample.
        ! Only supported for 'Diagonal Covariance' == true.
        Returns the gradient vector in sample["Gradient"] and the Hessian vector-of-vectors in sample["Hessian"].
        Dimensions of gradient and Hessian equal the (true) number of independent hyperparameters.
        Order of the hyperparameter dimensions in the output:
            First the mean, then the diagonal covariance entries, in order.
     @param sample: Should have populated fields 'Latent Variables' and 'Covariance Powers'.
                    'Covariance Powers' are powers of {1/2, 1, 3/2, 4/2} of a diagonal covariance matrix,
                     represented as vectors; one vector per power.
                     'Latent Variables' should be a nIndividuals x latentSpaceDimensions vector-of-vectors.

   */
  void evaluateLogProbabilityDerivatives(korali::Sample &sample);

  /// @brief Korali experiment needed to create the sub-problem
  korali::Experiment _koraliExperiment;

  /**
 * @brief Korali engine needed to initialize the lowlevel problem / experiment.
 */
  korali::Engine _koraliEngine;
};

} // namespace latent
} // namespace bayesian
} // namespace problem
} // namespace korali

#endif // _KORALI_PROBLEM_HIERARCHICALLATENT_HPP_
